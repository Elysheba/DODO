---
title: "Building DODO database"
author: "Liesbeth Fran√ßois"
date: "`r format(Sys.time(), '%B %d %Y')`"
abstract: "This report records the process the load the different disease ontologies into a single DODO instance and return an RDF table as well as RData objects with all parsed information."
output:
    html_document:
        fig_width: 9
        fig_height: 5
        keep_md: yes
        number_sections: yes
        theme: cerulean
        toc: yes
        toc_float: yes
params:
  type: "internal"
  name: "dodo"
editor_options: 
  chunk_output_type: console
---

<!----------------------------------------------------------------->
<!----------------------------------------------------------------->

# Introduction

This document shows how to build a Dictionary of Disease Ontologies (DODO). It can be adapted for specific needs or additional ontologies as required. The DODO functions used to feed the DB are not exported to avoid unintended modifications of the DB. To call them, they are preceded by `DODO:::`.

In this example several publically available disease ontologies are integrated into DODO. These ontologies have been parse beforehand and these scripts are made available through a GitHub repository (as described in the paper).

```{r config, message=FALSE}
##
library(DODO)
library(tidyverse)
library(readr)
library(stringr)
library(DT)
library(arrow)
library(data.table)
library(kableExtra)
##

setwd("/Local_Disk/Git_Repos/DODO/")

workingDirectory <- "/Local_Disk/working"

## Specific config
if(params$type == "internal"){
  dodoInstance <- "UCB-Internal"
}else{
  dodoInstance <- "UCB-Public"
}
dodoVersion <- format(Sys.Date(), "%Y.%m.%d")
## General config
curDate <- Sys.Date()
## Original resources location
# oriDir <- "~/Shared/Data-Science/Data-Source-Model-Repository"
## Connect to DODO database
# if(params$type == "internal"){
#   url <- "http://localhost:7475"
# }else{
#   url <- "http://localhost:7476"
# }

## tmp docker
url <- "http://localhost:7470"
# connect_to_dodo(
#    url = url,
#    importPath = "/data/lfrancois/Development/DODO/build/working/neo4jImport"
#    # importPath = "neo4jImport"
# )

```

<!----------------------------------------------------------------->
<!----------------------------------------------------------------->

# Data model

!["The DODO data model"](/data/lfrancois/Development/DODO/inst/documentation/data-model/DODO.svg)

# Load ontologies

The different ontologies included are MonDO, EFO, DO, Orphanet, MedGen, MeSH, HPO, ICD10CM, ICD11 (only ICD10 ids), Cortellis (if available) and ICD10CM. These files were parsed with the source scripts provided in the respective GitHub repositories. 

```{r load_onto, include = TRUE}
path_name <- "/Local_Disk/Reference_Files/DODO/processed_disease_ontos"
src <- list.dirs(path_name, full.names = F, recursive = F)
for(s in src){
  ddir <- file.path(path_name,s)
  dbfiles <- list.files(ddir)
  print(s)
  for(i in dbfiles){
    # print(i)
    
    if(grepl("CortellisONT", i)){
      x <- read.table(file.path(ddir,i),header = TRUE, sep = "\t", 
                quote = '"', comment.char = "", 
                colClasses= c("character")) %>% 
        as.data.table()
       assign(gsub(".txt","",i), x) 
    }else{
      x <- read_parquet(file.path(ddir,i)) %>% 
        as.data.table()
    
      if(grepl("parentId",i)){
          x$origin <- s
      }
      if(grepl("entryId", i)){
        if(grepl("MedGen|ICDO|HP|DO", s)){
          x$origin <- x$DB
        }else{
          x$origin <- s
        }
      }
      }
      assign(paste(s, gsub(".parquet|.txt","",i), sep = "_"), x) 
    }
}
```


# Harmonize CortellisONT

Harmonize information from CortellisONT when available.

```{r harm_cort, include = FALSE, echo = FALSE}
if(params$type == "internal"){
  # CortellisoNT_siConditions links to CortellisDD and CortellisONT_ciIndications links to CortesllisID
  library(polars)
  CortellisONT_siConditions <- CortellisONT_siConditions %>% 
    mutate(dbid = paste("Cortellis_condition", id, sep = ":"),
           DB = "Cortellis_condition", 
           origin = "Cortellis_condition", 
           def = NA, 
           name = gsub(paste("\n","\t","\r", sep = "|")," ", tolower(name)))
  CortellisONT_ciIndications <- CortellisONT_ciIndications %>% 
    mutate(dbid = paste("Cortellis_indication", id, sep = ":"),
           DB = "Cortellis_indication", 
           origin = "Cortellis_indication", 
           def = NA, 
           name = gsub(paste("\n","\t","\r", sep = "|")," ", tolower(name)))
  
  CortellisONT_entryId <- rbind(CortellisONT_siConditions, CortellisONT_ciIndications)
  
  ## Xref
  crossId1 <- CortellisONT_siConditionXref[, DB1:= "Cortellis_condition"] %>% 
    .[, `:=`(dbid1 = paste(DB1,conditionId, sep = ":"),
             dbid2 = paste(source, xref, sep = ":"))] %>%
    setnames(., c("source", "xref", "conditionId"), c("DB2", "id2", "id1")) %>%
    .[, -c("dbRef", "direct")]
    
  crossId2 <- CortellisONT_ciIndicationXref[, DB1:= "Cortellis_indication"] %>% 
    .[, `:=`(dbid1 = paste(DB1,indicationId, sep = ":"),
             dbid2 = paste(source, xref, sep = ":"))] %>%
    setnames(., c("source", "xref", "indicationId"), c("DB2", "id2", "id1")) %>%
    .[, -c("dbRef", "direct")]
  CortellisONT_crossId <- rbind(crossId1,crossId2)
  rm(crossId1, crossId2)
  
  
  ##================@
  ## ParentId
  parentId1 <- CortellisONT_siConditionParents[, `:=`(DB = "Cortellis_condition", 
                                                      pDB = "Cortellis_condition")] %>% 
    setnames(., c("depth", "parent"), c("level", "pid")) %>%
    .[, `:=`(dbid = paste(DB, id, sep = ":"),
             pdbid = paste(pDB, pid, sep = ":"))] %>% 
    .[level != 1,]
  parentId2 <- CortellisONT_ciIndicationParents[, `:=`(DB = "Cortellis_indication", 
                                                      pDB = "Cortellis_indication")] %>% 
    setnames(., c("depth", "parent"), c("level", "pid")) %>%
    .[, `:=`(dbid = paste(DB, id, sep = ":"),
             pdbid = paste(pDB, pid, sep = ":"))] %>% 
    .[level != 1,]

  CortellisONT_parentId <- rbind(parentId1, parentId2) %>% 
    .[, -c("level", "leaf", "treeCode")] %>% 
    .[, origin := DB]
  rm(parentId1, parentId2)

  ##
  CortellisONT_idNames <- copy(CortellisONT_entryId[, .(dbid, DB, id, name)]) %>% 
    setnames(., c("name"), c("synonym")) %>% 
    .[, canonical := TRUE]
}
```

# Integrate resources

The input tables from the different ontologies are integrated and checked for consistency.

```{r integrate}
##################################################################@
## Bind all datasets----
obj <- c("entryId","crossId","idNames","parentId","pheno","altId")

for(i in obj){
  dbobj <- grep(i,ls(),value = T)
  print(i)
  # sapply(dbobj,
  #          function(x){
  #            print(x)
  #            print(head(get(x), n = 2))
  #          })
  sobj <- unique(do.call(rbind,lapply(dbobj,function(x) get(x))))
  fn <- paste0("DODO_",i)
  assign(value = sobj,x = fn)
}

##################################################################@
## create dbid
DODO_crossId <- DODO_crossId[!is.na(id2)] %>% 
  unique()
  
DODO_pheno <- DODO_pheno[, `:=`(dDB = gsub(":.*", "", dbid),
                                    pDB = gsub(":.*", "", hp),
                                    did = gsub(".*:", "", dbid),
                                    pid = gsub(".*:", "", hp))] %>% 
  setnames(., c("hp"), c("pdbid"))


DODO_altId <- DODO_altId %>%
  setnames(., "altdbib", "adbid")

# check availability of def and assign label to def is it is NA
x <- copy(DODO_entryId[, def := case_when(is.na(def) ~ name,
                                                TRUE ~ def)]) %>% 
  .[, same := (DB==origin)] %>% 
  .[sort(same),]
  # select(-same)
## Adding names as canonical label if missing in idNames
nolabel <- DODO_entryId[!dbid %in% DODO_idNames$dbid]
## if identifiers have no label but a definition
table(is.na(DODO_idNames$syn))
toAdd <- DODO_entryId %>%
  filter(!dbid %in% DODO_idNames$dbid) %>% 
  mutate(canonical = TRUE) %>% 
  filter(!is.na(def)) %>% 
  select(DB, id, synonym = def, canonical, dbid) %>% 
  .[, synonym := trimws(gsub("[^[:alnum:]]", " ", synonym)) ] 
DODO_idNames <- DODO_idNames %>% 
  bind_rows(toAdd) %>%
  .[, synonym := trimws(gsub(",", " ", synonym))] %>%
  unique()

## Add identifiers to DODO_entryId if missing
toAdd <- copy(DODO_crossId[!dbid2 %in% DODO_entryId$dbid, .(dbid2, id2, DB2)]) %>% 
  setnames(., c("dbid2", "id2", "DB2"), c("dbid", "id", "DB")) %>% 
  .[, `:=`(origin = NA, name = NA, def = NA)] %>% 
  unique()
DODO_entryId <- rbind(DODO_entryId, toAdd) 

## remove disease ids from dodo_pheno if they are not in dodo_entry as they are not disease ids, but pheno ids themselves
DODO_pheno <- DODO_pheno[dbid %in% DODO_entryId$dbid & pdbid %in% DODO_entryId$dbid]

##
toAdd <- copy(DODO_altId[!adbid %in% DODO_entryId$dbid, .(adbid, altDB, altid)]) %>% 
  setnames(., c("adbid", "altDB", "altid"), c("dbid", "DB", "id")) %>% 
  .[, `:=`(name = NA, origin = NA, def = NA)]
DODO_entryId <- rbind(DODO_entryId, toAdd)  %>% unique()

# Some identifiers are multiple times in DODO_entryId
# will check if they have a label/def, if they are the same, if not, we will take the shortest label and combine the definition
DODO_entryId <- copy(DODO_entryId) %>% 
  .[, duplicated := .N > 1, by = dbid] %>% 
  .[, `:=`(name = trimws(gsub("[^[:alnum:]]", " ", name)),
           def = trimws(gsub("[^[:alnum:]]", " ", def)))]  %>% 
  .[, `:=`(name = min(unique(name)),
           def = paste(unique(na.omit(def)), collapse = " | ")), by = dbid] %>% 
  unique()
```

# Save files to csv

```{r}
# Create nodes 
instance.nodes = data.table(`name:ID` = "DODO", 
                           `instance:string` = dodoInstance, 
                           `version:LABEL` = dodoVersion)
# Create disease nodes
# we are going to add synonyms as an array of terms to the node attribute
table(DODO_entryId$origin)
toAdd <- copy(DODO_idNames) %>% 
  .[, syn := paste0('["', paste(unique(na.omit(synonym)), collapse = '";"'), '"]'), by = dbid] %>% 
  .[, N := .N, by = dbid] %>% 
  .[, .(dbid, syn, N)] %>% 
  unique()
disease.nodes <- DODO_entryId[origin != "HP" | is.na(origin), .(dbid, DB, id, name, def)] %>% 
  unique() %>% 
  .[, type := case_when(DB == "HP" ~ "Disease;Phenotype",
                        TRUE ~ "Disease")] %>% 
  .[, synonyms := toAdd$syn[match(dbid, toAdd$dbid)]] %>% 
  `colnames<-`(c("name:ID", "DB:string", "id:string", "name:string", "def:string", ":LABEL", "synonyms:string[]")) 
phenotype.nodes <- DODO_entryId[origin == "HP" & !dbid %in% disease.nodes$`name:ID`, 
                                .(dbid, DB, id, name, def)] %>% 
  unique() %>% 
  .[, type := "Phenotype"] %>% 
  .[, synonyms := toAdd$syn[match(dbid, toAdd$dbid)]] %>% 
  `colnames<-`(c("name:ID", "DB:string", "id:string", "name:string", "def:string", ":LABEL", "synonyms:string[]"))

databases <- readxl::read_xlsx(here::here("inst", "documentation", "DatabaseURLs.xlsx"), col_names = c("name", "idURL"))
db.nodes <- data.table(db_name = sort(unique(c(DODO_entryId[["DB"]], DODO_crossId[["DB1"]], DODO_crossId[["DB2"]])))) %>% 
  .[, DB := gsub("\\_.*", "", db_name)] %>% 
  .[, url := databases$idURL[match(DB, databases$name)]] %>% 
  .[, .(db_name, url)] %>% 
  .[, type := "Database"] %>% 
  `colnames<-`(c("name:ID", "url:string", ":LABEL"))

# Create edges
## database of origin
concept_db.edges <- DODO_entryId[!is.na(origin), .(dbid, origin)] %>% 
  .[, type := "is_in"] %>% 
  `colnames<-`(c(":START_ID", ":END_ID", ":TYPE")) %>% 
  unique()
## parent hierarchy
parent.edges <- DODO_parentId[, .(dbid, pdbid, origin)] %>% 
  .[, type := "is_a"] %>% 
  `colnames<-`(c(":START_ID", ":END_ID", "origin:string", ":TYPE")) %>% 
  unique()
table(parent.edges$`:START_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))
table(parent.edges$`:END_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))

# xref edges
# Some edges are is_xref (defined in the excel below) all others are is_related.
# In addition, I will do filtering on the edges to put in, avoiding ambigous relations to traverse between
## soooo evrything that is in the excel = is_xref with an attribute on the edge: confidence = 1
## everything that is not on the excel, attribute: confidence = 0
## within the is_xref, we are going to check the ambiguity, if it's higher than 1 (one-to-many) -> confidence = 0
## We have directed edges but duplicate them in both directions to calculate this ambiguity
## and we'll do this before ingestion and then just adapt the functions afterwards
xrefDB <- readxl::read_xlsx(file.path(getwd(), "inst", "documentation",
                                      "CrossreferencesEdges.xlsx"),
                            sheet = "Max_ambiguity_4_across_DBs"
                            ) %>% 
  as.data.table() %>% 
  .[, db_edge := paste(pmin(DB1, DB2), pmax(DB1, DB2), sep = "-")]
xref <- DODO_crossId[, .(dbid1, DB1, dbid2, DB2)] %>% 
  .[, type := "is_xref"] %>% 
  .[, db_edge := paste(pmin(DB1, DB2), pmax(DB1, DB2), sep = "-")] %>% 
  .[, confidence := case_when(db_edge %in% xrefDB$db_edge ~ 1, TRUE ~ 0)] 
xref.edges <-  rbind(xref[, .(dbid1, dbid2, DB2, type, db_edge, confidence)],
          xref[, .(dbid2, dbid1, DB1, type, db_edge, confidence)] %>% 
                  setnames(., c("dbid1", "dbid2", "DB1"), c("dbid2", "dbid1", "DB2"))) %>% 
  unique() %>% 
  .[, ambiguity := .N , by = c("dbid1", "DB2")] %>% 
  .[, confidence := case_when(ambiguity > 1 ~ 0,
                              TRUE ~ confidence)] %>% 
  .[, .(dbid1, dbid2, type, confidence, ambiguity)]  %>% 
  `colnames<-`(c(":START_ID", ":END_ID", ":TYPE", "confidence:int", "ambiguity:int"))
table(xref.edges$`:START_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))
table(xref.edges$`:END_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))


## alternative id
altid.edges <- DODO_altId[, .(dbid, adbid)] %>% 
  .[, type := "has_alternative_id"] %>% 
  `colnames<-`(c(":START_ID", ":END_ID", ":TYPE")) %>% 
  unique()
table(altid.edges$`:START_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))
table(altid.edges$`:END_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))


## phenotype to disease
pheno.edges <- DODO_pheno[, .(dbid, pdbid)] %>% 
  .[, type := "has_phenotype"] %>% 
  `colnames<-`(c(":START_ID", ":END_ID", ":TYPE")) %>% 
  unique()
table(pheno.edges$`:START_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))
table(pheno.edges$`:END_ID` %in% c(disease.nodes$`name:ID`, phenotype.nodes$`name:ID`))

toSave <- grep("edges|nodes", ls(), value = T)

walk(toSave, ~{
  print(.x)
  fwrite(get(.x), file = file.path("/Local_Disk/Reference_Files/DODO/final_disease_ontos", 
                                   paste0(.x, ".csv")))
})
```
