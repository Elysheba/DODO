---
title: "Building DODO database"
author: "Liesbeth Fran√ßois"
date: "`r format(Sys.time(), '%B %d %Y')`"
abstract: "This report records the process the load the different disease ontologies into a single DODO instance and return an RDF table as well as RData objects with all parsed information."
output:
    html_document:
        fig_width: 9
        fig_height: 5
        keep_md: yes
        number_sections: yes
        theme: cerulean
        toc: yes
        toc_float: yes
params:
  type: "internal"
  name: "dodo"
editor_options: 
  chunk_output_type: console
---

<!----------------------------------------------------------------->
<!----------------------------------------------------------------->

# Introduction

This document shows how to build a Dictionary of Disease Ontologies (DODO). It can be adapted for specific needs or additional ontologies as required. The DODO functions used to feed the DB are not exported to avoid unintended modifications of the DB. To call them, they are preceded by `DODO:::`.

In this example several publically available disease ontologies are integrated into DODO. These ontologies have been parse beforehand and these scripts are made available through a GitHub repository (as described in the paper).

```{r config, message=FALSE}
##
library(DODO)
library(tidyverse)
library(readr)
library(stringr)
library(DT)
library(arrow)
library(data.table)
library(kableExtra)
##

setwd("/Local_Disk/Git_Repos/DODO/")

workingDirectory <- "/Local_Disk/working"

## Specific config
if(params$type == "internal"){
  dodoInstance <- "UCB-Internal"
}else{
  dodoInstance <- "UCB-Public"
}
dodoVersion <- format(Sys.Date(), "%Y.%m.%d")
## General config
curDate <- Sys.Date()
## Original resources location
# oriDir <- "~/Shared/Data-Science/Data-Source-Model-Repository"
## Connect to DODO database
# if(params$type == "internal"){
#   url <- "http://localhost:7475"
# }else{
#   url <- "http://localhost:7476"
# }

## tmp docker
url <- "http://localhost:7470"
# connect_to_dodo(
#    url = url,
#    importPath = "/data/lfrancois/Development/DODO/build/working/neo4jImport"
#    # importPath = "neo4jImport"
# )

```

<!----------------------------------------------------------------->
<!----------------------------------------------------------------->

# Data model

!["The DODO data model"](/data/lfrancois/Development/DODO/inst/documentation/data-model/DODO.svg)

# Load ontologies

The different ontologies included are MonDO, EFO, DO, Orphanet, MedGen, MeSH, HPO, ICD10CM, ICD11 (only ICD10 ids), Cortellis (if available) and ICD10CM. These files were parsed with the source scripts provided in the respective GitHub repositories. 

```{r load_onto, include = TRUE}
path_name <- "/Local_Disk/Reference_Files/DODO/processed_disease_ontos"
src <- list.dirs(path_name, full.names = F, recursive = F)
for(s in src){
  ddir <- file.path(path_name,s)
  dbfiles <- list.files(ddir)
  print(s)
  for(i in dbfiles){
    # print(i)
    
    if(grepl("CortellisONT", i)){
      x <- read.table(file.path(ddir,i),header = TRUE, sep = "\t", 
                quote = '"', comment.char = "", 
                colClasses= c("character")) %>% 
        as.data.table()
       assign(gsub(".txt","",i), x) 
    }else{
      x <- read_parquet(file.path(ddir,i)) %>% 
        as.data.table()
    
      if(grepl("parentId",i)){
          x$origin <- s
      }
      if(grepl("entryId", i)){
        if(grepl("MedGen|ICDO", s)){
          x$origin <- x$DB
        }else{
          x$origin <- s
        }
      }
      }
      assign(paste(s, gsub(".parquet|.txt","",i), sep = "_"), x) 
    }
}
## to fix in the ICDO script
ICDO_parentId <- copy(ICDO_parentId[, `:=`(
  pid=gsub(".*\\_", "", pDB),
  pDB=gsub("\\_.*", "",pDB), 
  pdbid=gsub("_", ":",pdbid))])
ICDO_idNames <- copy(ICDO_idNames[, `:=`(
  id=gsub(".*\\_", "", DB),
  DB=gsub("\\_.*", "",DB), 
  dbid=gsub("_", ":",dbid))] )
# Fix DOID names and HPO
## also somewhere ORPHA (in HPO!)
```


# Format input tables

This script generates the different tables required to build the DODO Dgraph database and takes the files created by parsing the disease ontologies as input. The ontologies provided in public DODO instance are:

- MONDO (Monarch)
- EFO
- DO
- Orphanet
- MedGen
- MeSH
- HPO
- ICDO
- ClinVar

The URL provides a link to its respective GitHub repository where you can find the scripts to parse the different ontologies and generate the necessary input files for the current workflow. However, this workflow is easily adapted to include additional disease or phenotype ontologies. It requires parsing the ontology and generating files with specific format and specific table name. The table name is always constructes as follows: *name of the ontology*_*name table*, eg. "Monarch_entryId". The script will read these files with the specific table names from the global environment and append them automatically to each other. The format of each table is listed below, if information is not available or not provided in the ontology, the table doesn't need to be created. If specific information of a table is missing, please assign NA to that column. 

## Database convention

There are often different abbreviations available for different ontology database. Here, we adopt a naming convention to harmonize the different inputs.

```{r db_convention, echo = FALSE, include = TRUE}
toShow <- readxl::read_xlsx(file.path(getwd(), "inst", "documentation", "DatabaseDocumentation.xlsx"))
datatable(toShow,
          rownames = FALSE)
```

## Cross-reference edges

There are two types of cross-reference edges encoded into the database, *is_xref* and *is_related*.  The *is_xref* edge is used for equal cross-reference relationships where the concepts relate more directly to each other (similar concept levels). The *is_related* edge is used for all other cross-reference edges. These edges are defined based on the sum of forward and backward ambiguities between databases. Ontologies with a ambiguity equal or lower than 4 are considered as *is_xref* with the exception of ICD10 and ICD9 which are never an *is_xref* edge except between these two databases. In addition, MedGen and UMLS identifiers are duplicated therefore there is an additional *is_xref* edge between these. For more information please consult the vignette. 

```{r db_xref_edge, echo = FALSE, include = TRUE}
xrefDB <- readxl::read_xlsx(file.path(getwd(), "inst", "documentation",
                                      "CrossreferencesEdges.xlsx"),
                            sheet = "Max_ambiguity_4_across_DBs"
                            )
datatable(xrefDB,
          rownames = FALSE)
```

## Harmonize CortellisONT

Harmonize information from CortellisONT when available.

```{r harm_cort, include = FALSE, echo = FALSE}
if(params$type == "internal"){
  # CortellisoNT_siConditions links to CortellisDD and CortellisONT_ciIndications links to CortesllisID
  library(polars)
  CortellisONT_siConditions <- CortellisONT_siConditions %>% 
    mutate(dbid = paste("Cortellis_condition", id, sep = ":"),
           DB = "Cortellis_condition", 
           origin = "Cortellis_condition", 
           def = NA, 
           name = gsub(paste("\n","\t","\r", sep = "|")," ", tolower(name)))
  CortellisONT_ciIndications <- CortellisONT_ciIndications %>% 
    mutate(dbid = paste("Cortellis_indication", id, sep = ":"),
           DB = "Cortellis_indication", 
           origin = "Cortellis_indication", 
           def = NA, 
           name = gsub(paste("\n","\t","\r", sep = "|")," ", tolower(name)))
  
  CortellisONT_entryId <- rbind(CortellisONT_siConditions, CortellisONT_ciIndications)
  
  ## Xref
  crossId1 <- CortellisONT_siConditionXref[, DB1:= "Cortellis_condition"] %>% 
    .[, `:=`(dbid1 = paste(DB1,conditionId, sep = ":"),
             dbid2 = paste(source, xref))] %>%
    setnames(., c("source", "xref", "conditionId"), c("DB2", "id2", "id1")) %>%
    .[, -c("dbRef", "direct")]
    
  crossId2 <- CortellisONT_ciIndicationXref[, DB1:= "Cortellis_indication"] %>% 
    .[, `:=`(dbid1 = paste(DB1,indicationId, sep = ":"),
             dbid2 = paste(source, xref))] %>%
    setnames(., c("source", "xref", "indicationId"), c("DB2", "id2", "id1")) %>%
    .[, -c("dbRef", "direct")]
  CortellisONT_crossId <- rbind(crossId1,crossId2)
  rm(crossId1, crossId2)
  
  
  ##================@
  ## ParentId
  parentId1 <- CortellisONT_siConditionParents[, `:=`(DB = "Cortellis_condition", 
                                                      pDB = "Cortellis_condition")] %>% 
    setnames(., c("depth", "parent"), c("level", "pid")) %>%
    .[, `:=`(dbid = paste(DB, id, sep = ":"),
             pdbid = paste(pDB, pid, sep = ":"))] %>% 
    .[level != 1,]
  parentId2 <- CortellisONT_ciIndicationParents[, `:=`(DB = "Cortellis_indication", 
                                                      pDB = "Cortellis_indication")] %>% 
    setnames(., c("depth", "parent"), c("level", "pid")) %>%
    .[, `:=`(dbid = paste(DB, id, sep = ":"),
             pdbid = paste(pDB, pid, sep = ":"))] %>% 
    .[level != 1,]

  CortellisONT_parentId <- rbind(parentId1, parentId2) %>% 
    .[, -c("level", "leaf", "treeCode")] %>% 
    .[, origin := DB]
  rm(parentId1, parentId2)

  ##
  CortellisONT_idNames <- copy(CortellisONT_entryId[, .(dbid, DB, id, name)]) %>% 
    setnames(., c("name"), c("synonym")) %>% 
    .[, canonical := TRUE]
}
```

# Integrate resources

The input tables from the different ontologies are integrated and checked for consistency.

```{r integrate}
##################################################################@
## Bind all datasets----
obj <- c("entryId","crossId","idNames","parentId","pheno","altId")

for(i in obj){
  dbobj <- grep(i,ls(),value = T)
  print(i)
  sapply(dbobj,
           function(x){
             print(x)
             print(names(get(x)))
           })
  sobj <- unique(do.call(rbind,lapply(dbobj,function(x) get(x))))
  fn <- paste0("DODO_",i)
  assign(value = sobj,x = fn)
}

##################################################################@
## create dbid
DODO_entryId <- DODO_entryId %>%
  .[!DB %in% c("https", "BFO")] %>% 
  unique()
  
DODO_pheno <- DODO_pheno[, `:=`(dDB = gsub(":.*", "", dbid),
                                    pDB = gsub(":.*", "", hp),
                                    did = gsub(".*:", "", dbid),
                                    pid = gsub(".*:", "", hp))] %>% 
  setnames(., c("hp"), c("pdbid"))

DODO_idNames <- DODO_idNames %>% 
  .[!grepl("BFO|https|icdo.owl|PATO|RO|UBERON", DB),] 

# Just some fun mismatching in the cross reference DBs
DODO_crossId$DB2 <- gsub("-", "", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("MedDRA", "MEDDRA", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("Medgen|MEDGEN", "MedGen", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("MESH", "MeSH", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("ORDO|Orphanet", "ORPHA", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("SNOMED_CT|SCTID", "SNOMEDCT", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("UMLS_CUI", "UMLS", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("MIM", "OMIM", DODO_crossId$DB2)
DODO_crossId$DB2 <- gsub("NCIT", "NCIt", DODO_crossId$DB2)

# replace_db <- c("MedDRA" = "MEDDRA", 
#                 "Medgen" = "MedGen", 
#                 "MEDGEN" = "MedGen",
#                 "MESH" = "MeSH", 
#                 "ORDO" = "Orphanet",
#                 "ORPHA" = "Orphanet",
#                 "SNOMED_CT" = "SNOMEDCT",
#                 "SCTID" = "SNOMEDCT",
#                 "UMLS_CUI" = "UMLS",
#                 "MIM" = "OMIM",
#                 "NCIT", "NCIt")

DODO_crossId$dbid2 <- paste(DODO_crossId$DB2, DODO_crossId$id2, sep = ":")


DODO_altId <- DODO_altId %>%
  setnames(., "altdbib", "adbid")
```

## Check label and definition information

```{r}
x <- copy(DODO_entryId[, def := case_when(is.na(def) ~ name,
                                                TRUE ~ def)]) %>% 
  .[, same := (DB==origin)] %>% 
  .[sort(same),]
  # select(-same)
## Adding names as canonical label if missing in idNames
nolabel <- DODO_entryId[!dbid %in% DODO_idNames$dbid]

  
## if identifiers have no label but a definition
## 
table(is.na(DODO_idNames$syn))
nolabel <- DODO_entryId %>%
  filter(!dbid %in% DODO_idNames$dbid) %>% 
  mutate(canonical = "TRUE") %>% 
  filter(!is.na(def)) %>% 
  select(DB, id, syn = def, canonical, dbid)
head(nolabel)
table(gsub(":.*", "", unique(nolabel$dbid)))
head(DODO_idNames)

dim(DODO_idNames)
DODO_idNames <- DODO_idNames %>% 
  bind_rows(nolabel) %>% 
  distinct()
dim(DODO_idNames)
```



# Save csv

```{r}
DODO_instance = data.table(name = "DODO", instance = dodoInstance, version = dodoVersion)

toSave <- grep("DODO", ls(), value = T)


walk(toSave, ~{
  fwrite(get(.x), file = file.path(getwd()))
})
## db version
## need to rewrite this in nodes and edges, also putting concept (Disease/Phenotype) in there
## and is_xref or is_related edges
## For origin, I think perhaps it should be is_in edge and nodes = dodo_entry without origin
## Parent edges will have attributes
## DBs should have there url templates as attributes
```


# DODO:::load_dodo_model()

<!-- concept <- "Concept" -->


## Concepts

```{r}
toImport <- DODO_entryId %>%
  select(
    database = DB,
    shortID = id,
    definition= def,
    label = syn,
    name = dbid,
    level,
    origin
  ) %>%
  arrange(desc(level)) %>%
  filter(database == origin) %>% ## First only DB = origin, to add original DBs, later add additional databases
  distinct(name, .keep_all = T)
toAdd <-  DODO_entryId %>%
  select(
    database = DB,
    shortID = id,
    definition= def,
    label = syn,
    name = dbid,
    level,
    origin
  ) %>%
  arrange(desc(level)) %>%
  filter(database != origin) %>%
  filter(!name %in% toImport$name)
toImport <- bind_rows(toImport, toAdd) %>%
  distinct()
# toImport$origin <- db
concept <- "Concept"
stopifnot(nrow(distinct(toImport, name))==nrow(toImport))
DODO:::load_concept_definitions(toImport=toImport, concept=concept)
```

## Synonyms

```{r}
toImport <- DODO_idNames %>%
  select("database"=DB, 
         "shortID"=id, 
         "name" = dbid,
         "value"=syn) %>%
  distinct()
DODO:::load_concept_synonyms(toImport=toImport, concept=concept)
```

## Alternative identifiers

```{r}
toImport <- DODO_altId %>%
  select("database"="DB", 
         "shortID"="id", 
         "altdb"="altDB", 
         "altid"="alt")
DODO:::load_alternative_identifiers(toImport=toImport, concept=concept)
```

## Parents

```{r}
toImport <- DODO_parentId %>%
  select("database"=DB, 
         "shortID"=id, 
         "parentdb"=pDB, 
         "parentid"=parent,
         origin)
DODO:::load_parent_identifiers(toImport=toImport, concept=concept)
```

## Cross-references

```{r}
xrefDB <- readxl::read_xlsx(here::here("inst", "documentation",
                                       "CrossreferencesEdges.xlsx"),
                            sheet = "Max_ambiguity_4_across_DBs")
datatable(xrefDB,
          rownames = FALSE)
toImport <- DODO_crossId %>%
  select(DB1, id1, DB2, id2)
DODO:::load_cross_references(
  toImport = toImport, 
  xrefDB = xrefDB, 
  concept = concept
)
```

## Diseases - Phenotypes

```{r}
nodes <- DODO_entryId %>% filter(DB == "HP") %>% pull(dbid)
DODO:::set_labels(concept = "Phenotype", nodes = nodes)

nodes <- DODO_entryId %>% filter(DB != "HP") %>% pull(dbid)
DODO:::set_labels(concept = "Disease", nodes = nodes)

toImport <- DODO_pheno2dis %>%
  select(diseaseDB = disDB, 
         diseaseID = disID, 
         phenoID = phenoID,
         phenoDB = phenoDB)
DODO:::load_has_phenotypes(toImport=toImport)
```

## Connect nodes to databases

Some identifiers are recorded across multiple database, e.g. EFO incorporates identifiers from Monarch, Orphanet, etc. These receive additional *is_in* edge.

```{r}
# toImport <- bind_rows(DODO_parentId %>% select(DB,
#                                                id, 
#                                                origin),
#                       DODO_parentId %>% select(DB = pDB,
#                                                id = parent,
#                                                origin)) %>%
#   distinct() %>%
#   select(database = DB,
#          shortID = id,
#          origin)
toImport <- DODO_entryId %>%
  select(
    database = DB,
    shortID = id,
    name = dbid,
    level,
    origin
  ) %>%
  arrange(desc(level)) %>%
  distinct(name, origin, .keep_all = T)
DODO:::load_concept_names(toImport = toImport, concept = concept)
```

# Database URL templates

```{r db_url, echo = FALSE, include = TRUE}
databases <- readxl::read_xlsx(here::here("inst", "documentation", "DatabaseURLs.xlsx"), col_names = c("name", "idURL"))
# datatable(databases,
#           rownames = FALSE)
DODO:::load_db_definitions(toImport=databases)
```

## Write files

Files are writting to the specified location both as rdf and rda files.

```{r write_files}
############################@
## Save .rda ----
############################@
toSave <- grep("^DODO[_]", ls(), value=T)
save(list = toSave,
     file = here("..","data",
                 paste0(params$name, "-neo4j-input-files.rda")))
```
